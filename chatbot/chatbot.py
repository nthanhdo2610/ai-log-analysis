import traceback
import re
import json
from configuration import ELKLogRetriever, QDrantLogStore, ClaudeAnalyzer, LogEmbeddingProcessor, LangfuseLogger


class ELKChatbot:
    def __init__(self, es_config, embedding_model, qdrant_db, claude_config, langfuse_keys):
        self.log_retriever = ELKLogRetriever(**es_config)
        self.logger = LangfuseLogger(**langfuse_keys)

        # Initialize embedding processor and pass it to QDrant
        self.embedding_processor = LogEmbeddingProcessor(embedding_model)
        self.qdrant_store = QDrantLogStore(**qdrant_db)

        # Use ClaudeAnalyzer for Claude-based tasks
        self.analyzer = ClaudeAnalyzer(**claude_config)

        # ✅ Store user-related context
        self.user_context = {}

    def update_context(self, key, value):
        """ Store relevant query context (e.g., last user, last action). """
        self.user_context[key] = value

    def get_context(self, key):
        """ Retrieve stored context if available. """
        return self.user_context.get(key, None)

    def extract_json_from_response(self, response_text):
        """Extract a valid JSON object from Claude's response (robust against bad formatting)."""
        # First try to extract from ```json fenced block
        match = re.search(r'```json\s*(\{.*?\})\s*```', response_text, re.DOTALL)
        if match:
            json_text = match.group(1)
        else:
            # Try to extract from any generic code block
            match = re.search(r'```\s*(\{.*?\})\s*```', response_text, re.DOTALL)
            if match:
                json_text = match.group(1)
            else:
                # Fallback: extract first { ... } block in text
                match = re.search(r'(\{.*\})', response_text, re.DOTALL)
                json_text = match.group(1) if match else ""

        try:
            return json.loads(json_text)
        except json.JSONDecodeError:
            print("❌ Claude response (raw):", response_text)
            raise ValueError("Failed to extract a valid JSON query from Claude's response.")


    def process_query(self, query):
        try:
            # Step 1: Use Claude to determine if ES data is needed
            classification_prompt = f"""
            Determine if the following query requires retrieving logs from Elasticsearch. 
            If yes, return 'RETRIEVE'. If not, return 'RESPOND'.
            Query: {query}
            """
            classification = self.analyzer.claude.invoke(classification_prompt).content.strip()

            if classification == "RESPOND":
                response = self.analyzer.claude.invoke(
                    f"Provide a response based on previous conversation memory: {query}"
                ).content
                return response

            # Step 2: Retrieve Last Identified User from Context
            last_user = self.get_context("last_user")
            
            # Step 3: Generate Elasticsearch Query using Claude
            es_query_prompt = f"""
            Given the Elasticsearch index mapping below:
            {json.dumps(self.log_retriever.mapping, indent=2)}

            Convert the following natural language query into a valid Elasticsearch query:
            {query}

            Ensure:
            - Identify the most relevant fields from the index mapping dynamically.
            - If the query includes a user reference, include all possible user-related fields dynamically.
            - If no user is explicitly mentioned, default to the last identified user: {last_user}.
            - Use "term" instead of "match" for exact match fields (such as `keyword` or `long` type fields).
            - Use "term" for "loglevel.keyword" and ensure it is always uppercase.
            - Use "bool" query with "should" inside "must" for multiple user-related fields.
            - Identify the correct timestamp field dynamically (e.g., use "@timestamp" if available).
            - Apply range filtering to the correct timestamp field.
            - loglevel is upper (such as ERROR, WARN, TRACE, DEBUG, INFO).
            - Ensure proper JSON format.
            - Respond only with valid JSON inside a JSON code block.
            """
            es_query_response = self.analyzer.claude.invoke(es_query_prompt).content
            es_query = self.extract_json_from_response(es_query_response)

            # Set no size limit (retrieve all relevant logs)
            es_query["size"] = 10000

            # Validate ES Query Structure
            if "query" not in es_query or "bool" not in es_query["query"]:
                raise ValueError("Invalid Elasticsearch query structure generated by Claude.")

            # Step 4: Query Elasticsearch for Logs
            es_response = self.log_retriever.search_logs(es_query)

            if not es_response:
                return "No relevant logs found."

            logs = es_response if isinstance(es_response, list) else es_response.get("hits", {}).get("hits", [])
            aggregations = es_response.get("aggregations", {}) if isinstance(es_response, dict) else {}

            # Step 5: Store Logs in QDrant for Semantic Search
            embeddings = self.embedding_processor.embed_logs(logs)
            self.qdrant_store.store_logs(logs, embeddings)

            # Step 6: Retrieve Similar Logs from QDrant
            query_embedding = self.embedding_processor.embed_query(query)
            similar_logs = self.qdrant_store.search_similar_logs(query_embedding, k=5)

            # Step 7: Analyze and Summarize Logs using Claude
            analysis_prompt = f"""
            Analyze the following logs and summarize key user activities:

            {json.dumps(similar_logs, indent=2)}

            Rules:
            1️⃣ Extract and summarize user actions based on logs, even if they are not explicitly listed in aggregations.
            2️⃣ Identify **explicit user actions** such as LOGIN, NAVIGATION, FORM SUBMISSION, API CALLS.
            3️⃣ Ignore system errors unless they are directly related to a user's action.
            4️⃣ If logs contain similar repeated actions, summarize them instead of listing each individually.
            5️⃣ Do **not** claim there is no activity if logs contain user actions.
            6️⃣ Enhance the analysis using the similar logs retrieved from QDrant.
            7️⃣ Answer the follow-up question in brief and professional:
            {query}
            """
            analysis = self.analyzer.claude.invoke(analysis_prompt).content

            self.logger.log_interaction(query, analysis)
            return analysis
        except Exception as e:
            error_message = f"An error occurred: {str(e)}"
            print(traceback.format_exc())
            return error_message
